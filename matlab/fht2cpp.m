function fht2cpp = fht2cpp() %#codegen

fprintf('\n===================================================\n');
fprintf('=              Fast Hartley transform             =\n');
fprintf('===================================================\n');

%% choose test signal (if test mixer is enabled - test signal is number):
    %test = 'sin';      % sine in 3 harmonics
    %test = 'imp';      % impulse response
    %test = 'signal';   % real signal from 'wav'
    %test = 'const';    % const bias
    
%% variables:

%dir_def = '../fht_defines.v';

dir_sin_coef = 'sin.txt';
dir_cos_coef = 'cos.txt';

% dir of input signal sample and impulses ('h.txt', 'x.txt' must be autogenerated, cause 'Nh', 'Nx' defines by 'fht_defines.v'):
    dir_imp     = '../../gcpu/sample/h.txt'; % size Nh

% save reg ver of files for init FPGA RAM in tb:    
    dir_init_fht    = 'init_fht_ram.txt';  
    dir_init_imp_p  = '../../fht_conv/matlab/init_imp_p_ram.txt'; 
    dir_init_imp_n	= '../../fht_conv/matlab/init_imp_n_ram.txt';

% dir output math for compare in matlab and tb:
    dir_math_fht_ram	= 'math_fht_ram.txt';
    dir_math_fft_line   = 'math_fft_cp.txt';
    
N_bank = 4; % defines by architecture of transform in FPGA (don't change for this config)

% read files:
    N       = 2048;
    Nx      = 64;
    Nh      = 1984;
    row     = 512;
    d_bit	= 21;
    imp_bit	= 16;
    w_amp	= 65536;
    adc_amp	= 32768;

fprintf('\nInput data:\n');
fprintf('\tNum of point transform (N)\t\t\t= %d\n',     N(int16));
fprintf('\tNum of point signal in RAM (Nx)\t\t= %d\n',	Nx(int16));
fprintf('\tNum of point impulses in RAM (Nh)\t= %d\n',	Nh(int16));
fprintf('\tRAM bank size\t= %d\n',          row(int16));
fprintf('\tData width\t\t= %d\n',           d_bit(int16));
fprintf('\tImpulse coef width\t\t= %d\n',   imp_bit(int32));
fprintf('\tAmp of Sin/Cos coef\t\t= %d\n',  w_amp(int32));
fprintf('\tAmp of input signal on ADC\t\t= %d\n',  adc_amp(int32));

%% get input data:
fprintf('\nGet input data...\n');

file_imp = fopen(dir_imp, 'r');

if(file_imp == -1)
   error('Error: file does not exist "%s"', dir_imp);
end

str_imp = fread(file_imp);

fclose(file_imp);

str_imp = char(str_imp(:).');

idx = isstrprop(str_imp,'wspace');
idy = diff([true,idx,true]);

idb = find(idy<0);
ide = find(idy>0)-1;

test_signal = zeros(N,1);

for i = 1:N
    test_signal(i) = str2double(str_imp(idb(i):ide(i)));
end

fprintf('\nForming input RAM for FHT...');

k = 0;
ram = zeros(row, N_bank);

for i = 1:N_bank
    for j = 1:row
        k = k + 1;
        
    % bit reverse bank order:
        switch(i)
            case 1
                ram(j, 1) = test_signal(k);
            case 2
                ram(j, 3) = test_signal(k);
            case 3
                ram(j, 2) = test_signal(k);
            case 4
                ram(j, 4) = test_signal(k);
        end
    end
end

%% normalize signal in FPGA bit width:
fprintf('\n\tNormalize input signal\n');

max_amp = max(abs(test_signal));

norm_coef_p = (adc_amp - 1)/max_amp;
norm_coef_n = adc_amp/max_amp;

if(max_amp >= adc_amp)
    for i = 1:N_bank
        for j = 1:row
            if(ram(j, i) < 0)
                ram(j, i) = round(ram(j, i)*norm_coef_n);
            else
                ram(j, i) = round(ram(j, i)*norm_coef_p);
            end
        end
    end

    for i = 1:N
        if(test_signal(i) < 0)
            test_signal(i) = round(test_signal(i)*norm_coef_n);
        else
            test_signal(i) = round(test_signal(i)*norm_coef_p);
        end
    end
end

%% fht:
fprintf('\nStart FPGA model of FHT...\n');

sin_x = load(dir_sin_coef);
cos_x = load(dir_cos_coef);

file_ram = fopen(dir_init_fht, 'w');

if(file_ram ~= -1)
	for i = 1 : row
        fprintf(file_ram, '%6.6f\t%6.6f\t%6.6f\t%6.6f\n', ram(i, :));
	end
else
    error('Error: file name is wrong "%s"', dir_init_fht);
end

temp = zeros(4, 1);

for i = 1:row % 0 stage (only butterfly)
    x = [ram(i, 1), ram(i, 2), 0];
    y = [ram(i, 3), ram(i, 4), 0];
    
    sin_but = [sin_x(1), sin_x(1)];
    cos_but = [cos_x(1), cos_x(1)];
                           
    mul_x = (cos_but(1)*x(2) + sin_but(1)*x(3))/w_amp;
    mul_y = (cos_but(2)*y(2) + sin_but(2)*y(3))/w_amp;

    temp(1) = (x(1) + mul_x)/2;
    temp(2) = (x(1) - mul_x)/2;

    temp(3) = (y(1) + mul_y)/2;
    temp(4) = (y(1) - mul_y)/2;
                           
    ram(i, :) = [temp(1), temp(3), temp(2), temp(4)];
end

last_stage = log(N)/log(2) - 1; % numbers start from zero
fprintf('\n\tTotal num of stages transform: %d\n', last_stage);

% init coef for 1st stage:
    bit_depth = log(row)/log(2) - 2; % bit depth of ROM data: [A_BIT - 3 : 0]	
    div = N/(2*N_bank);
    sector = 1;
    
for stage = 1:last_stage % without 0 stage
    fprintf('\t\tCurrent stage transform: %d\n', stage);
    
    ram_buf = zeros(row, N_bank);

    sector_size = 1;
	sector_cnt = 2;

	cos_cnt = 0;
	
	for j = 1:sector
        num_coef = bin2dec(fliplr(dec2bin(cos_cnt, bit_depth))) + 1;
        
        for i = (1 + (j-1)*2*div):(2*div + (j-1)*2*div)
            if(j == 1)
                x = [ram(i, 1), ram(i, 2), ram(i, 2)];
                y = [ram(i, 3), ram(i, 4), ram(i, 4)];

                sin_but = [sin_x(num_coef), cos_x(num_coef)];
                cos_but = [cos_x(num_coef), -sin_x(num_coef)];

                mul_x = (cos_but(1)*x(2) + sin_but(1)*x(3))/w_amp;
                mul_y = (cos_but(2)*y(2) + sin_but(2)*y(3))/w_amp;

                temp(1) = (x(1) + mul_x)/2;
                temp(2) = (x(1) - mul_x)/2;

                temp(3) = (y(1) + mul_y)/2;
                temp(4) = (y(1) - mul_y)/2;
			elseif(j == 2)
                x = [ram(i, 2), ram(i, 1), ram(i, 3)];
                y = [ram(i, 4), ram(i, 3), ram(i, 1)];

                sin_but = [sin_x(num_coef), cos_x(num_coef)];
                cos_but = [cos_x(num_coef), -sin_x(num_coef)];

                mul_x = (cos_but(1)*x(2) + sin_but(1)*x(3))/w_amp;
                mul_y = (cos_but(2)*y(2) + sin_but(2)*y(3))/w_amp;

                temp(1) = (x(1) + mul_x)/2;
                temp(2) = (x(1) - mul_x)/2;

                temp(3) = (y(1) + mul_y)/2;
                temp(4) = (y(1) - mul_y)/2;
			elseif(mod(j, 2) == 1)
                x = [ram(i, 1), ram(i, 2), ram(i + sector_cnt*2*div, 3)];
                y = [ram(i, 3), ram(i, 4), ram(i + sector_cnt*2*div, 1)];

                sin_but = [sin_x(num_coef), cos_x(num_coef)];
                cos_but = [cos_x(num_coef), -sin_x(num_coef)];

                mul_x = (cos_but(1)*x(2) + sin_but(1)*x(3))/w_amp;
                mul_y = (cos_but(2)*y(2) + sin_but(2)*y(3))/w_amp;

                temp(1) = (x(1) + mul_x)/2;
                temp(2) = (x(1) - mul_x)/2;

                temp(3) = (y(1) + mul_y)/2;
                temp(4) = (y(1) - mul_y)/2;
            else
                x = [ram(i, 2), ram(i, 1), ram(i + sector_cnt*2*div, 4)];
                y = [ram(i, 4), ram(i, 3), ram(i + sector_cnt*2*div, 2)];

                sin_but = [sin_x(num_coef), cos_x(num_coef)];
                cos_but = [cos_x(num_coef), -sin_x(num_coef)];

                mul_x = (cos_but(1)*x(2) + sin_but(1)*x(3))/w_amp;
                mul_y = (cos_but(2)*y(2) + sin_but(2)*y(3))/w_amp;

                temp(1) = (x(1) + mul_x)/2;
                temp(2) = (x(1) - mul_x)/2;

                temp(3) = (y(1) + mul_y)/2;
                temp(4) = (y(1) - mul_y)/2;
            end
            
            if(stage == last_stage)
				ram_buf(i, 1) = temp(1);
				ram_buf(i, 2) = temp(2);
				ram_buf(i, 3) = temp(3);
				ram_buf(i, 4) = temp(4);
			elseif(i > (div + (j-1)*2*div))
				ram_buf(i - div, 2) = temp(1);
				ram_buf(i - div, 4) = temp(2);
				ram_buf(i, 1) = temp(3);
				ram_buf(i, 3) = temp(4);
			else
				ram_buf(i, 1) = temp(1);
				ram_buf(i, 3) = temp(2);
				ram_buf(i + div, 2) = temp(3);
				ram_buf(i + div, 4) = temp(4);
            end
        end
        
        if((sector_cnt == -(sector_size - 1)) && (j >= 2))
			sector_size = 2*sector_size;
			sector_cnt = sector_size - 1;
		else
			sector_cnt = sector_cnt - 2;
        end
        
        if(cos_cnt == (row/4 - 1)) % overflow
            cos_cnt = 0;
        else
            cos_cnt = cos_cnt + 1;
        end
	end

	div = div/2;
	sector = 2*sector;
    
	ram = ram_buf;
end

%% save final RAM data in files:
fprintf('\nSave output RAM after transform for tb...');

file_ram = fopen(dir_math_fht_ram, 'w');
if(file_ram ~= -1)
    for i = 1 : row
        fprintf(file_ram, '%6.6f\t%6.6f\t%6.6f\t%6.6f\n', ram(i, :));
    end
    fclose(file_ram); 
else
    error('Error: file name is wrong "%s"', dir_math_fht_ram); 
end

file_fft_cp = fopen(dir_math_fft_line, 'w'); % for compare in analys
if(file_fft_cp ~= -1)
    for i = 1 : N
        fprintf(file_fft_cp, '%6.6f\n', fft_line(i)); 
    end
    fclose(file_fft_cp);
else
    error('Error: file name is wrong "%s"', dir_math_fft_line); 
end

%% save fixed point version of IMP RAM POS/NEG FHT for conv:
    fprintf('\nSave integer (reg) version output RAM impulses for FPGA...');

    ram_p = zeros(row, N_bank);
    ram_n = zeros(row, N_bank);

    ram_p(1, :) = ram(1, :) + ram(1, [1,2,4,3]);
    ram_p(2, :) = ram(2, :) + ram(2, [4,3,2,1]);

    ram_n(1, :) = ram(1, :) - ram(1, [1,2,4,3]);
    ram_n(2, :) = ram(2, :) - ram(2, [4,3,2,1]);

    cnt = 3;
    for i = 2 : 1 : log2(row)
        for j = (2^i - 1): -1 : (2^(i - 1))
            ram_p(cnt, :) = ram(cnt, :) + ram(j + 1, [4,3,2,1]);
            ram_n(cnt, :) = ram(cnt, :) - ram(j + 1, [4,3,2,1]);

            cnt = cnt + 1;
        end
    end

    % save fixed point version of RAM for conv:
        abs_max_ram = 0;

        for i = 1 : row
            cur_max_ram = max(abs(ram_p(i,:)));

            if(cur_max_ram > abs_max_ram)
                abs_max_ram = cur_max_ram;
            end
        end

        file_reg = fopen(dir_init_imp_p, 'w');
        if(file_reg == -1)
            error('Error: file name is wrong "%s"', dir_init_imp_p); 
        end

        norm_coef_p = (2^(imp_bit - 1) - 1)/abs_max_ram;
        norm_coef_n = (2^(imp_bit - 1))/abs_max_ram;

        % fixed point for FPGA like registers:
        reg_ram = zeros(row, N_bank);

        for i = 1:N_bank
            for j = 1:row
                if(ram_p(j, i) < 0)
                    reg_ram(j, i) = round(ram_p(j, i)*norm_coef_n);
                else
                    reg_ram(j, i) = round(ram_p(j, i)*norm_coef_p);
                end
            end
        end

        for i = 1 : row
            fprintf(file_reg, '%6d\t%6d\t%6d\t%6d\n', reg_ram(i, :));
        end

        fclose(file_reg);
    
    % save fixed point version of RAM for conv:
        abs_max_ram = 0;

        for i = 1 : row
            cur_max_ram = max(abs(ram_n(i,:)));

            if(cur_max_ram > abs_max_ram)
                abs_max_ram = cur_max_ram;
            end
        end

        file_reg = fopen(dir_init_imp_n, 'w');
        if(file_reg == -1)
            error('Error: file name is wrong "%s"', dir_init_imp_n); 
        end

        norm_coef_p = (2^(imp_bit - 1) - 1)/abs_max_ram;
        norm_coef_n = (2^(imp_bit - 1))/abs_max_ram;

        % fixed point for FPGA like registers:
        reg_ram = zeros(row, N_bank);

        for i = 1:N_bank
            for j = 1:row
                if(ram_n(j, i) < 0)
                    reg_ram(j, i) = round(ram_n(j, i)*norm_coef_n);
                else
                    reg_ram(j, i) = round(ram_n(j, i)*norm_coef_p);
                end
            end
        end

        for i = 1 : row
            fprintf(file_reg, '%6d\t%6d\t%6d\t%6d\n', reg_ram(i, :));
        end

        fclose(file_reg);
    
fprintf('\n===================================================\n');
fprintf('=                    Complete                     =\n');
fprintf('===================================================\n');

fht2cpp = 0;